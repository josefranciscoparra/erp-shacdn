"use server";

/**
 * Server Actions para Liquidaciones de Vacaciones
 *
 * Funcionalidades:
 * - Calcular liquidación para un empleado
 * - Crear liquidación (manual)
 * - Auto-crear liquidación al finalizar contrato
 * - Actualizar estado de liquidación (PENDING → PAID/COMPENSATED)
 * - Obtener liquidaciones de un empleado
 * - Obtener liquidaciones de la organización
 *
 * Permisos: Solo ADMIN y HR_MANAGER pueden crear/modificar liquidaciones
 */

import { revalidatePath } from "next/cache";

import type { Prisma } from "@prisma/client";
import { Role } from "@prisma/client";
import { Decimal } from "@prisma/client/runtime/library";

import { auth } from "@/lib/auth";
import { computeEffectivePermissions } from "@/lib/auth-guard";
import { prisma } from "@/lib/prisma";
import { calculateSettlementBalance, type VacationCalculation } from "@/lib/vacation-calculator";

// =====================================================
// TIPOS
// =====================================================

export interface CreateSettlementData {
  employeeId: string;
  contractId?: string;
  settlementDate: Date;
  notes?: string;
}

export interface SettlementResult {
  success: boolean;
  error?: string;
  settlement?: {
    id: string;
    employeeId: string;
    settlementDate: Date;
    accruedDays: number;
    usedDays: number;
    pendingDays: number;
    balanceDays: number;
    status: string;
  };
}

export interface UpdateSettlementStatusData {
  settlementId: string;
  status: "PENDING" | "PAID" | "COMPENSATED";
  notes?: string;
}

export interface SettlementListItem {
  id: string;
  employeeId: string;
  employeeName: string;
  employeeNumber: string | null;
  contractId: string | null;
  settlementDate: Date;
  accruedDays: number;
  usedDays: number;
  pendingDays: number;
  balanceDays: number;
  status: string;
  isAutoGenerated: boolean;
  notes: string | null;
  createdAt: Date;
  createdByName: string;
}

// =====================================================
// VALIDACIÓN DE PERMISOS
// =====================================================

interface PermissionsResult {
  valid: boolean;
  userId: string;
  orgId: string;
  userEmail: string;
  userName: string;
  userRole: string;
  error?: string;
}

async function validatePermissions(): Promise<PermissionsResult> {
  const session = await auth();

  if (!session?.user?.id) {
    return { valid: false, userId: "", orgId: "", userEmail: "", userName: "", userRole: "", error: "No autenticado" };
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { id: true, orgId: true, role: true, email: true, name: true },
  });

  if (!user) {
    return {
      valid: false,
      userId: "",
      orgId: "",
      userEmail: "",
      userName: "",
      userRole: "",
      error: "Usuario no encontrado",
    };
  }

  const effectivePermissions = await computeEffectivePermissions({
    role: user.role as Role,
    orgId: user.orgId,
    userId: user.id,
  });

  if (!effectivePermissions.has("manage_payroll")) {
    return {
      valid: false,
      userId: user.id,
      orgId: user.orgId,
      userEmail: user.email,
      userName: user.name ?? "",
      userRole: user.role,
      error: "No tienes permisos para gestionar liquidaciones. Solo Admin y RRHH pueden hacerlo.",
    };
  }

  return {
    valid: true,
    userId: user.id,
    orgId: user.orgId,
    userEmail: user.email,
    userName: user.name ?? "",
    userRole: user.role,
  };
}

// =====================================================
// SERVER ACTIONS - CÁLCULO
// =====================================================

/**
 * Calcula la liquidación de vacaciones para un empleado
 * NO guarda en base de datos, solo devuelve el cálculo
 */
export async function calculateSettlement(employeeId: string, cutoffDate: Date): Promise<VacationCalculation> {
  const session = await auth();
  if (!session?.user?.id) {
    throw new Error("No autenticado");
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { orgId: true },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  // Verificar que el empleado pertenece a la organización
  const employee = await prisma.employee.findUnique({
    where: { id: employeeId },
    select: { orgId: true },
  });

  if (!employee) {
    throw new Error("Empleado no encontrado");
  }

  if (employee.orgId !== user.orgId) {
    throw new Error("No tienes acceso a este empleado");
  }

  return calculateSettlementBalance(employeeId, cutoffDate);
}

// =====================================================
// SERVER ACTIONS - CREAR LIQUIDACIÓN
// =====================================================

/**
 * Crea una liquidación de vacaciones (manual)
 * Primero calcula el balance y luego lo guarda
 */
export async function createSettlement(data: CreateSettlementData): Promise<SettlementResult> {
  try {
    const permissions = await validatePermissions();
    if (!permissions.valid) {
      return { success: false, error: permissions.error };
    }

    // Verificar que el empleado pertenece a la organización
    const employee = await prisma.employee.findUnique({
      where: { id: data.employeeId },
      select: {
        id: true,
        orgId: true,
        firstName: true,
        lastName: true,
      },
    });

    if (!employee) {
      return { success: false, error: "Empleado no encontrado" };
    }

    if (employee.orgId !== permissions.orgId) {
      return { success: false, error: "No tienes acceso a este empleado" };
    }

    // Calcular el balance de liquidación
    const calculation = await calculateSettlementBalance(data.employeeId, data.settlementDate);

    // Crear la liquidación
    const settlement = await prisma.$transaction(async (tx) => {
      const newSettlement = await tx.vacationSettlement.create({
        data: {
          orgId: permissions.orgId,
          employeeId: data.employeeId,
          contractId: data.contractId ?? null,
          settlementDate: data.settlementDate,
          accruedDays: new Decimal(calculation.accruedDays),
          usedDays: new Decimal(calculation.usedDays),
          pendingDays: new Decimal(calculation.pendingDays),
          balanceDays: new Decimal(calculation.balanceDays),
          accruedMinutes: calculation.accruedMinutes,
          usedMinutes: calculation.usedMinutes,
          pendingMinutes: calculation.pendingMinutes,
          balanceMinutes: calculation.balanceMinutes,
          workdayMinutes: calculation.workdayMinutes,
          status: "PENDING",
          notes: data.notes ?? null,
          isAutoGenerated: false,
          createdBy: permissions.userId,
        },
      });

      // Registrar en auditoría
      const employeeName = `${employee.firstName} ${employee.lastName}`;
      await tx.auditLog.create({
        data: {
          orgId: permissions.orgId,
          action: "SETTLEMENT_CREATED",
          category: "VACATION_SETTLEMENT",
          entityId: newSettlement.id,
          entityType: "VacationSettlement",
          entityData: {
            employeeId: data.employeeId,
            employeeName,
            settlementDate: data.settlementDate.toISOString(),
            accruedDays: calculation.accruedDays,
            usedDays: calculation.usedDays,
            pendingDays: calculation.pendingDays,
            balanceDays: calculation.balanceDays,
            isAutoGenerated: false,
          },
          description: `Liquidación de vacaciones creada para ${employeeName}`,
          performedById: permissions.userId,
          performedByEmail: permissions.userEmail,
          performedByName: permissions.userName,
          performedByRole: permissions.userRole,
        },
      });

      return newSettlement;
    });

    // Revalidar paths
    revalidatePath("/dashboard/settlements");
    revalidatePath(`/dashboard/employees/${data.employeeId}`);

    return {
      success: true,
      settlement: {
        id: settlement.id,
        employeeId: settlement.employeeId,
        settlementDate: settlement.settlementDate,
        accruedDays: Number(settlement.accruedDays),
        usedDays: Number(settlement.usedDays),
        pendingDays: Number(settlement.pendingDays),
        balanceDays: Number(settlement.balanceDays),
        status: settlement.status,
      },
    };
  } catch (error) {
    console.error("Error al crear liquidación:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Error al crear la liquidación",
    };
  }
}

/**
 * Crea una liquidación automáticamente al finalizar un contrato
 * Esta función se llama desde el proceso de finalización de contrato
 */
export async function autoCreateSettlement(
  contractId: string,
  settlementDate: Date,
  performedByUserId: string,
): Promise<SettlementResult> {
  try {
    // Obtener contrato con empleado
    const contract = await prisma.employmentContract.findUnique({
      where: { id: contractId },
      include: {
        employee: {
          select: {
            id: true,
            orgId: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    if (!contract) {
      return { success: false, error: "Contrato no encontrado" };
    }

    // Calcular el balance de liquidación
    const calculation = await calculateSettlementBalance(contract.employeeId, settlementDate);

    // Crear la liquidación
    const settlement = await prisma.$transaction(async (tx) => {
      const newSettlement = await tx.vacationSettlement.create({
        data: {
          orgId: contract.orgId,
          employeeId: contract.employeeId,
          contractId: contractId,
          settlementDate: settlementDate,
          accruedDays: new Decimal(calculation.accruedDays),
          usedDays: new Decimal(calculation.usedDays),
          pendingDays: new Decimal(calculation.pendingDays),
          balanceDays: new Decimal(calculation.balanceDays),
          accruedMinutes: calculation.accruedMinutes,
          usedMinutes: calculation.usedMinutes,
          pendingMinutes: calculation.pendingMinutes,
          balanceMinutes: calculation.balanceMinutes,
          workdayMinutes: calculation.workdayMinutes,
          status: "PENDING",
          notes: "Liquidación generada automáticamente al finalizar contrato",
          isAutoGenerated: true,
          createdBy: performedByUserId,
        },
      });

      // Registrar en auditoría
      const employeeName = `${contract.employee.firstName} ${contract.employee.lastName}`;

      // Obtener datos del usuario que ejecuta la acción
      const performedByUser = await tx.user.findUnique({
        where: { id: performedByUserId },
        select: { email: true, name: true, role: true },
      });

      await tx.auditLog.create({
        data: {
          orgId: contract.orgId,
          action: "SETTLEMENT_AUTO_CREATED",
          category: "VACATION_SETTLEMENT",
          entityId: newSettlement.id,
          entityType: "VacationSettlement",
          entityData: {
            contractId,
            employeeId: contract.employeeId,
            employeeName,
            settlementDate: settlementDate.toISOString(),
            accruedDays: calculation.accruedDays,
            usedDays: calculation.usedDays,
            pendingDays: calculation.pendingDays,
            balanceDays: calculation.balanceDays,
            isAutoGenerated: true,
            reason: "Contrato finalizado",
          },
          description: `Liquidación de vacaciones auto-generada para ${employeeName} por finalización de contrato`,
          performedById: performedByUserId,
          performedByEmail: performedByUser?.email ?? "sistema@timenow.cloud",
          performedByName: performedByUser?.name ?? "Sistema",
          performedByRole: performedByUser?.role ?? "SYSTEM",
        },
      });

      return newSettlement;
    });

    // Revalidar paths
    revalidatePath("/dashboard/settlements");
    revalidatePath(`/dashboard/employees/${contract.employeeId}`);
    revalidatePath(`/dashboard/contracts/${contractId}`);

    return {
      success: true,
      settlement: {
        id: settlement.id,
        employeeId: settlement.employeeId,
        settlementDate: settlement.settlementDate,
        accruedDays: Number(settlement.accruedDays),
        usedDays: Number(settlement.usedDays),
        pendingDays: Number(settlement.pendingDays),
        balanceDays: Number(settlement.balanceDays),
        status: settlement.status,
      },
    };
  } catch (error) {
    console.error("Error al auto-crear liquidación:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Error al crear la liquidación automática",
    };
  }
}

// =====================================================
// SERVER ACTIONS - ACTUALIZAR ESTADO
// =====================================================

/**
 * Actualiza el estado de una liquidación
 * PENDING → PAID (pagada) o COMPENSATED (compensada con días)
 */
export async function updateSettlementStatus(data: UpdateSettlementStatusData): Promise<SettlementResult> {
  try {
    const permissions = await validatePermissions();
    if (!permissions.valid) {
      return { success: false, error: permissions.error };
    }

    // Obtener liquidación actual
    const currentSettlement = await prisma.vacationSettlement.findUnique({
      where: { id: data.settlementId },
      include: {
        employee: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    if (!currentSettlement) {
      return { success: false, error: "Liquidación no encontrada" };
    }

    if (currentSettlement.orgId !== permissions.orgId) {
      return { success: false, error: "No tienes acceso a esta liquidación" };
    }

    const previousStatus = currentSettlement.status;

    // Actualizar liquidación
    const settlement = await prisma.$transaction(async (tx) => {
      const updatedSettlement = await tx.vacationSettlement.update({
        where: { id: data.settlementId },
        data: {
          status: data.status,
          notes: data.notes ?? currentSettlement.notes,
        },
      });

      // Registrar en auditoría
      const employeeName = `${currentSettlement.employee.firstName} ${currentSettlement.employee.lastName}`;
      await tx.auditLog.create({
        data: {
          orgId: permissions.orgId,
          action: "SETTLEMENT_STATUS_UPDATED",
          category: "VACATION_SETTLEMENT",
          entityId: data.settlementId,
          entityType: "VacationSettlement",
          entityData: {
            previousStatus,
            newStatus: data.status,
            employeeId: currentSettlement.employeeId,
            employeeName,
            notes: data.notes ?? null,
          },
          description: `Estado de liquidación actualizado a ${data.status} para ${employeeName}`,
          performedById: permissions.userId,
          performedByEmail: permissions.userEmail,
          performedByName: permissions.userName,
          performedByRole: permissions.userRole,
        },
      });

      return updatedSettlement;
    });

    // Revalidar paths
    revalidatePath("/dashboard/settlements");
    revalidatePath(`/dashboard/settlements/${data.settlementId}`);
    revalidatePath(`/dashboard/employees/${settlement.employeeId}`);

    return {
      success: true,
      settlement: {
        id: settlement.id,
        employeeId: settlement.employeeId,
        settlementDate: settlement.settlementDate,
        accruedDays: Number(settlement.accruedDays),
        usedDays: Number(settlement.usedDays),
        pendingDays: Number(settlement.pendingDays),
        balanceDays: Number(settlement.balanceDays),
        status: settlement.status,
      },
    };
  } catch (error) {
    console.error("Error al actualizar estado de liquidación:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Error al actualizar la liquidación",
    };
  }
}

// =====================================================
// SERVER ACTIONS - CONSULTAS
// =====================================================

/**
 * Obtiene las liquidaciones de un empleado específico
 */
export async function getEmployeeSettlements(employeeId: string): Promise<SettlementListItem[]> {
  const session = await auth();
  if (!session?.user?.id) {
    throw new Error("No autenticado");
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { orgId: true },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  // Verificar que el empleado pertenece a la organización
  const employee = await prisma.employee.findUnique({
    where: { id: employeeId },
    select: { orgId: true },
  });

  if (!employee) {
    throw new Error("Empleado no encontrado");
  }

  if (employee.orgId !== user.orgId) {
    throw new Error("No tienes acceso a este empleado");
  }

  const settlements = await prisma.vacationSettlement.findMany({
    where: {
      employeeId,
      orgId: user.orgId,
    },
    include: {
      employee: {
        select: {
          firstName: true,
          lastName: true,
          employeeNumber: true,
        },
      },
    },
    orderBy: { settlementDate: "desc" },
  });

  // Obtener nombres de creadores
  const creatorIds = [...new Set(settlements.map((s) => s.createdBy))];
  const creators = await prisma.user.findMany({
    where: { id: { in: creatorIds } },
    select: { id: true, name: true },
  });
  const creatorMap = new Map(creators.map((c) => [c.id, c.name]));

  return settlements.map((s) => ({
    id: s.id,
    employeeId: s.employeeId,
    employeeName: `${s.employee.firstName} ${s.employee.lastName}`,
    employeeNumber: s.employee.employeeNumber,
    contractId: s.contractId,
    settlementDate: s.settlementDate,
    accruedDays: Number(s.accruedDays),
    usedDays: Number(s.usedDays),
    pendingDays: Number(s.pendingDays),
    balanceDays: Number(s.balanceDays),
    status: s.status,
    isAutoGenerated: s.isAutoGenerated,
    notes: s.notes,
    createdAt: s.createdAt,
    createdByName: creatorMap.get(s.createdBy) ?? "Sistema",
  }));
}

/**
 * Obtiene todas las liquidaciones de la organización
 * Con filtros opcionales por estado y rango de fechas
 */
export async function getOrganizationSettlements(filters?: {
  status?: "PENDING" | "PAID" | "COMPENSATED";
  fromDate?: Date;
  toDate?: Date;
}): Promise<SettlementListItem[]> {
  const session = await auth();
  if (!session?.user?.id) {
    throw new Error("No autenticado");
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { orgId: true },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  const where: Prisma.VacationSettlementWhereInput = {
    orgId: user.orgId,
  };

  if (filters?.status) {
    where.status = filters.status;
  }

  if (filters?.fromDate || filters?.toDate) {
    where.settlementDate = {};
    if (filters.fromDate) {
      where.settlementDate.gte = filters.fromDate;
    }
    if (filters.toDate) {
      where.settlementDate.lte = filters.toDate;
    }
  }

  const settlements = await prisma.vacationSettlement.findMany({
    where,
    include: {
      employee: {
        select: {
          firstName: true,
          lastName: true,
          employeeNumber: true,
        },
      },
    },
    orderBy: { settlementDate: "desc" },
  });

  // Obtener nombres de creadores
  const creatorIds = [...new Set(settlements.map((s) => s.createdBy))];
  const creators = await prisma.user.findMany({
    where: { id: { in: creatorIds } },
    select: { id: true, name: true },
  });
  const creatorMap = new Map(creators.map((c) => [c.id, c.name]));

  return settlements.map((s) => ({
    id: s.id,
    employeeId: s.employeeId,
    employeeName: `${s.employee.firstName} ${s.employee.lastName}`,
    employeeNumber: s.employee.employeeNumber,
    contractId: s.contractId,
    settlementDate: s.settlementDate,
    accruedDays: Number(s.accruedDays),
    usedDays: Number(s.usedDays),
    pendingDays: Number(s.pendingDays),
    balanceDays: Number(s.balanceDays),
    status: s.status,
    isAutoGenerated: s.isAutoGenerated,
    notes: s.notes,
    createdAt: s.createdAt,
    createdByName: creatorMap.get(s.createdBy) ?? "Sistema",
  }));
}

/**
 * Obtiene el detalle de una liquidación específica
 */
export async function getSettlementDetail(settlementId: string) {
  const session = await auth();
  if (!session?.user?.id) {
    throw new Error("No autenticado");
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { orgId: true },
  });

  if (!user) {
    throw new Error("Usuario no encontrado");
  }

  const settlement = await prisma.vacationSettlement.findUnique({
    where: { id: settlementId },
    include: {
      employee: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          employeeNumber: true,
        },
      },
      organization: {
        select: {
          name: true,
          annualPtoDays: true,
        },
      },
    },
  });

  if (!settlement) {
    throw new Error("Liquidación no encontrada");
  }

  if (settlement.orgId !== user.orgId) {
    throw new Error("No tienes acceso a esta liquidación");
  }

  // Obtener nombre del creador
  const creator = await prisma.user.findUnique({
    where: { id: settlement.createdBy },
    select: { name: true },
  });

  return {
    id: settlement.id,
    employeeId: settlement.employeeId,
    employeeName: `${settlement.employee.firstName} ${settlement.employee.lastName}`,
    employeeNumber: settlement.employee.employeeNumber,
    organizationName: settlement.organization.name,
    annualPtoDays: settlement.organization.annualPtoDays,
    contractId: settlement.contractId,
    settlementDate: settlement.settlementDate,
    accruedDays: Number(settlement.accruedDays),
    usedDays: Number(settlement.usedDays),
    pendingDays: Number(settlement.pendingDays),
    balanceDays: Number(settlement.balanceDays),
    accruedMinutes: settlement.accruedMinutes,
    usedMinutes: settlement.usedMinutes,
    pendingMinutes: settlement.pendingMinutes,
    balanceMinutes: settlement.balanceMinutes,
    workdayMinutes: settlement.workdayMinutes,
    status: settlement.status,
    isAutoGenerated: settlement.isAutoGenerated,
    notes: settlement.notes,
    createdAt: settlement.createdAt,
    updatedAt: settlement.updatedAt,
    createdByName: creator?.name ?? "Sistema",
  };
}

/**
 * Elimina una liquidación (solo si está en estado PENDING)
 */
export async function deleteSettlement(settlementId: string): Promise<{ success: boolean; error?: string }> {
  try {
    const permissions = await validatePermissions();
    if (!permissions.valid) {
      return { success: false, error: permissions.error };
    }

    // Obtener liquidación actual
    const settlement = await prisma.vacationSettlement.findUnique({
      where: { id: settlementId },
      include: {
        employee: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    if (!settlement) {
      return { success: false, error: "Liquidación no encontrada" };
    }

    if (settlement.orgId !== permissions.orgId) {
      return { success: false, error: "No tienes acceso a esta liquidación" };
    }

    if (settlement.status !== "PENDING") {
      return {
        success: false,
        error: "Solo se pueden eliminar liquidaciones en estado Pendiente",
      };
    }

    await prisma.$transaction(async (tx) => {
      // Eliminar liquidación
      await tx.vacationSettlement.delete({
        where: { id: settlementId },
      });

      // Registrar en auditoría
      const employeeName = `${settlement.employee.firstName} ${settlement.employee.lastName}`;
      await tx.auditLog.create({
        data: {
          orgId: permissions.orgId,
          action: "SETTLEMENT_DELETED",
          category: "VACATION_SETTLEMENT",
          entityId: settlementId,
          entityType: "VacationSettlement",
          entityData: {
            employeeId: settlement.employeeId,
            employeeName,
            settlementDate: settlement.settlementDate.toISOString(),
            balanceDays: Number(settlement.balanceDays),
          },
          description: `Liquidación de vacaciones eliminada para ${employeeName}`,
          performedById: permissions.userId,
          performedByEmail: permissions.userEmail,
          performedByName: permissions.userName,
          performedByRole: permissions.userRole,
        },
      });
    });

    // Revalidar paths
    revalidatePath("/dashboard/settlements");
    revalidatePath(`/dashboard/employees/${settlement.employeeId}`);

    return { success: true };
  } catch (error) {
    console.error("Error al eliminar liquidación:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Error al eliminar la liquidación",
    };
  }
}
